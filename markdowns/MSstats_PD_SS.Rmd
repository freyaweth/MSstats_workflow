---
title: "MSstats workflow"
author: "Sam Siljee"
date: '2022-11-18'
output: html_document
---

Created: 2022/11/18 Last modified: 2023/01/30 Written by: Sam Siljee

This is my script to run proteomics data from mass spectrometry through the `MSstats` package for normalisation, quantification, and some QC. This is based on the following tutorial:

<https://meenachoi.github.io/MayInstitute2019RstatsMS/>

Please see the tutorial or the `MSstats` package help for details on how to use the package, for any other assistance or advice you can contact Sam at [samsiljee\@gmail.com](mailto:samsiljee@gmail.com){.email} or through his github:

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Note that `MSstats` is a Bioconductor package, and will need to be installed through Biocondutor rather than CRAN; BiocManager::install("MSstats")
library(MSstats)
library(tidyverse)
library(EnhancedVolcano)

# Specify input and output directories. Modify as appropriate
input_dir <- "~/Coding/MSstats-tutorial/data/OT_vs_IT/"
output_dir <- "~/Coding/MSstats-tutorial/data/OT_vs_IT/output/"
```

# Data import

This workflow is to import data at the PSM table from Proteome Discoverer 2.4 (PD). Although quantification and normalisation is done better in R, you still need to run all samples in the same analysis in order for PD to include precursor abundance in the output table. After running the analysis in PD, select File \> Export \> To Text (tab delimited), and save with an appropriate name. Copy it to the input folder. THis chunk reads in the raw PSM table and annotations file, and formats them for use by `MSstats`. The generated input object takes the form of a data.frame with appropriate columns.

```{r data import, echo = FALSE}
# Read raw data from PSM table
raw <- read.csv(paste(input_dir, "15_50_quan_PSMs.txt", sep = ""),
                sep = "\t",
                stringsAsFactors = FALSE)

# Manually add (rename) the columns required in the `PDtoMSstatsFormat` call
raw <- raw %>%
  mutate(ProteinGroupAccessions = .$Protein.Accessions,
         PrecursorArea = .$Precursor.Abundance,
         Run = .$Spectrum.File)

# Read annotations file. This should at least include columns for run, condition, and biological replicate. Every row should be a seperate run
annot_col <- read.csv(paste(input_dir, "col_annotation.csv", sep = ""),
                      sep = ",",
                      stringsAsFactors = TRUE)

# Format for `MSstats`. Please see ?PDtoMSstatsFormat for details on arguments
input <- PDtoMSstatsFormat(raw, 
                           annotation = annot_col,
                           removeProtein_with1Peptide = FALSE,
                           which.quantification = "Precursor.Abundance",
                           which.proteinid = "Protein.Accessions",
                           removeFewMeasurements = TRUE)

# Briefly check input
head(input)

# Count the number of proteins
paste("There are", (input$ProteinName %>% unique %>% length), "proteins in this dataset")

# Check the column names in "input"
colnames(input)
```

# Data Processing

This chunk processes the input data including normalisation, censored cutoff, cleaning, and protein-level summarization. It saves the result in the output folder in the R data format. Please see `?dataProcess` for details on arguments for normalisation methods etc. Note that it gives warnings "Warning: Ran out of iterations and did not converge" I understand that this does not affect the output. The output object is structured as a list of three; 1. data.frame "FeatureLevelData" of PSM abundances, new abundances, censored etc. 2. data.frame "ProteinLevelData" of intensities and some QC stuff, missing features, imputed features, etc. 3. character "SummaryMethod", describing the method used (Tukey's median polish)

```{r data processing, echo = FALSE}
# Process the input
processed <- dataProcess(input,
                         normalization = 'equalizeMedians',
                         summaryMethod = "TMP",
                         censoredInt = "NA",
                         MBimpute = TRUE,
                         maxQuantileforCensored = 0.999,
                         verbose = TRUE)

# Save results
save(processed, file = paste(output_dir, "processed.rda", sep = ""))
```

# Data visualisation

These plots are from functions built-in to `MSstats` and are for quality control.

```{r data visualisation, echo = FALSE}
# This produces a boxplot, of intensity by sample. Used as a basic way to check normalisation
dataProcessPlots(processed,
                 type = "QCplot", 
                 ylimDown = 0, 
                 which.Protein = "allonly",
                 width = 7,
                 height = 7,  
                 address = paste(output_dir, "MSstats_", sep = ""))

# Produces individual plots for the different proteins, each peptide shown in a different colour
dataProcessPlots(processed,
                 type = "Profileplot", 
                 ylimDown = 0, 
                 originalPlot = TRUE,
                 summaryPlot = TRUE,
                 width = 7,
                 height = 7,  
                 address = paste(output_dir, "MSstats_", sep = ""))

# Produces a plot for each protein, with the estimated abundance for each protein as based on the modified mixed linear effects model used by `MSstats`
dataProcessPlots(processed,
                 type = "Conditionplot", 
                 ylimDown = 0, 
                 width = 7,
                 height = 7,  
                 address = paste(output_dir, "MSstats_", sep = ""))
```

# Model-based comparison, and adjusted p-value

First you will need to set up a comparison matrix describing which samples to compare to the others. This is dependant on the order of your runs. A matrix is used with each row as a particular combination of comparisons. Alternatively, "pairwise" for contrast.matrix argument. I was initially getting an error in the `groupComparison` call, however I believe this is due to the fact that I had uneven numbers of runs. The sum of each row of the comparison matrix should always be 0, with each group totalling to one. This can be fixed by using fractions when indicating multiple samples from the same group. However, I have not quite gotten this to work yet. The output file is a list of 3 elements; 1. data.frame "ComparisonResult" with log2FC, pvalue, etc. by protein 2. data.frame "ModelQC" with abundances etc 3. list "FittedModel" with one model for each protein of class 'lmerMod' from the `lme4` package

```{r model based comparison, echo = FALSE}
# Set up the comparison matrix.
comparison <- matrix(c(1, 0, 0, 0, -1), nrow = 1)
rownames(comparison) <- c("15cm-50cm")
colnames(comparison) <- c("15cm", "15cm", "15cm", "50cm", "50cm")

# Run the test
test.MSstats <- groupComparison(contrast.matrix = "pairwise",
                                data = processed)
# Extracting the comparison results
MSstats.results <- test.MSstats$ComparisonResult

# Checking for outliers, results in which there is an infinite fold-change
outliers <- which(MSstats.results$log2FC == Inf)
paste("There are", length(outliers), "outliers where the adjusted P value is zero, and fold-change is infinite", sep = " ")

# Remove outliers
MSstats.results <- MSstats.results[-outliers,]

# Remove rows with NAs for p value/adjusted p value
MSstats.results <- MSstats.results[!is.na(MSstats.results$adj.pvalue),]

# Add column for up/downregulated or non-significant
MSstats.results$Dif <- ifelse(MSstats.results$log2FC > 1 & MSstats.results$adj.pvalue < 0.05,
                                 "Upregulated",
                                 ifelse(MSstats.results$log2FC < -1 & MSstats.results$adj.pvalue < 0.05,
                                        "Downregulated",
                                        "Not significant"))

# save the results
save(MSstats.results, file = paste(output_dir, "MSstats.results.rda", sep = ""))
write.csv(MSstats.results, file = paste(output_dir, "MSstatsResults.csv", sep = ""))
```

# Comparison plots

```{r comparison plots, echo = FALSE}
#Basic volcano plot of results using `MSstats` function
groupComparisonPlots(data = MSstats.results,
                     type = "VolcanoPlot",
                     width = 6,
                     height = 6,
                     address = paste(output_dir, "MSstats_"))

# Volcano plot using old code
EnhancedVolcano(MSstats.results,
                lab = rownames(MSstats.results),
                x = "log2FC",
                y = "adj.pvalue",
                FCcutoff = 1,
                pCutoff = 0.05)

# Define colours for use in ggplot
colours <- c("red", "blue", "black") 
names(colours) <- c("Upregulated", "Downregulated", "Not significant")

# Volcano plot using ggplot
volcano <- MSstats.results %>%
  ggplot(aes(x = log2FC, y = -log10(adj.pvalue), col = Dif)) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", colour = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", colour = "red") +
  geom_point(alpha = 0.25, show.legend = FALSE) +
  scale_color_manual(values = colours) +
  xlim(-15, 15) +
  ylim(0, 10) +
  ylab("-Log10(adjusted p-value)") +
  xlab("Log2 fold change")

# Save plot
ggsave(filename = paste(output_dir, "ggvolcano.png", sep = ""),
       plot = volcano,
       width = 6,
       height = 6)

#Individual plots of log2FC with error bars for each protein
groupComparisonPlots(data = MSstats.results,
                     type = "ComparisonPlot",
                     width = 6,
                     height = 6,
                     address = paste(output_dir, "MSstats_"))
```
